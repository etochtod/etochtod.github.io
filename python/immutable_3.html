<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Пітон - об'єкти</title>
    <link rel="stylesheet" type="text/css" href="pages.css" />
    <script type="text/javascript" src="pages.js"></script>
    <script defer src="pyscript.js"></script>
    <script type="text/javascript" src="immutable_3.js"></script>
</head>
<body onload="start()">
    <div id="left">
        <div id="navbar">
            <a href="../index.html">На головну</a>
        </div>
<h2>Завдання 3:</h2>
<p>Переставити (не прибирати) три методи так щоб на єкран вивелося вітання, де кожне слово починається з великої літери.</p>
<span class="blue">upper().title().lower()</span>
<p>Змінна <i>s1</i> в результаті виконання кода повинна поміняти своє значення. Змінна <i>s2</i> зайва. Прибрати її разом з командою <span class="blue">print(...)</span> для неї.</p>
<p>Список <i>list1</i> повинен залишитися з початковим значенням <span class="blue">[10, 20]</span>. Список <i>list2</i> повинен прийняти значення <span class="blue">[10, 20, 15]</span>.</p>
<br>

<h2>Викликання методів:</h2>

<h3>Ланцюг викликів</h3>
<p>Синтаксис з крапкою є своєрідним конвеєром по переробці даних, де дані починають свій шлях зліва. У виразі<br><span class="blue">a = b.method1().method2().method3()</span> послідовність виконання буде наступною:</p>
<ul>
    <li>береться об'єкт <i>b</i>.</li>
    <li><span class="blue">методу1</span> передається значення <i>b</i>. <span class="blue">Метод1</span> виконується.</li>
    <li>результат виконання передається <span class="blue">методу2</span>. <span class="blue">Метод2</span> виконується.</li>
    <li>результат виконання передається <span class="blue">методу3</span>. <span class="blue">Метод3</span> виконується.</li>
    <li>результат виконання привласнюється змінній <i>a</i>. Вона починає вказувати на цей об'єкт-результат. І цей результат не знищується після виконання рядка завдяки цій змінній.</li>
</ul>
<p>Тобто, якщо ми маємо ланцюг з методів, поділених крапками, то виконання йде зліва направо, так як ми чи читаємо. В кінці, після виконання методів, результат привласнюється змінній.</p>
<p>Деякі методи просто щось роблять і не повертають результат. Такий метод буде крайнім зправа, після нього вже не можна продовжувати ланцюг. Результат привласнювати змінній також немає сенсу. Його немає.</p>
<pre>
lst = [10, 20]
lst.append(15) <span class="green"># додати 15 в кінець списка</span>
print(lst) <span class="green"># [10, 20, 15]</span>
</pre>
<p>Цей приклад виконує метод <span class="blue">append()</span> який додає в кінець списка нове значення. Метод не повертає результат - він просто міняє список який йому переданий. Після нього вже не вийде продовжувати ланцюг, а якщо результат привласнити змінній, то буде <i>None</i>.</p>
<br>
<h3>Mutable та immutable</h3>
<p>Коли метод приймає параметри для обробки, то параметри можуть прийти до нього у вигляді <b>копії</b> об'єкта або <b>оригінала</b> об'єкта.</p>
<p>Прикладом передавання копії може слугувати метод <span class="blue">s.upper()</span> - цьому методу передається копія рядка, і він міняє та повертає копію. Змінна <i>s</i> при цьому залишається як і була раніше.</p>
<p>Прикладом передавання оригінала є <span class="blue">lst.append(15)</span> - йому передається сам список <i>lst</i> для прямої модифікації.</p>
<p>В деяких мовах програмування можна явно задати як ми передаємо параметри до метода. В пітоні все залежить від типу даних. Певні типи даних завжди передаються як копія, вони називаються <span class="blue">immutable</span>, а інші передаються як оригінал - <span class="blue">mutable</span>.</p>
<p>До <span class="blue">immutable</span> типів відносяться числа (<span class="blue">i=5</span>), рядки (<span class="blue">s="hi"</span>), булеві змінні (<span class="blue">a=True</span>), кортежі (<span class="blue">c = (10, 20, 15)</span>), та ще декілька простих типів.</p>
<p>До <span class="blue">mutable</span> відносяться більш складні типи (<span class="blue">lst = [10, 20, 15]</span>). Вони важкі, і їх накладно передавати, створюючи копію кожного разу.</p>
<p>Таким чином, якщо ми передаємо методу рядок як параметр, то це ніяк не може бути оригінал. Метод <span class="blue">s.upper()</span> не має доступу до оригінального рядка. Метод <span class="blue">lst.append(15)</span> навпаки, отримує завжди оригінал списка.</p>
<p>Отримавши оригінал списка, методу ніщо не заважає потім зробити копію і повернути її. Метод <span class="blue">lst.copy()</span> саме це і робить. Він отримує оригінал <i>lst</i> і повертає його копію.</p>
<pre>
new_list = lst.copy() <span class="green"># зробити копію змінної lst</span>
</pre>
    </div>
    <div id="right">
        <textarea id="tArea" name="pcode" rows="12" cols="50"></textarea>
        <div id="dragger"></div>
        <div>
            <span id="run" onclick="run()">RUN</span><span id="reset" onclick="reset()">RESET</span>
            <span id="next" onclick="next()">NEXT</span>
        </div>
        <div id="result">
        </div>
    </div>
</body>
</html>